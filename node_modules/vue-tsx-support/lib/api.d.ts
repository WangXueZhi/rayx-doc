import Vue, { ComponentOptions, FunctionalComponentOptions, VueConstructor, VNodeData } from "vue";
import { RecordPropsDefinition, ThisTypedComponentOptionsWithRecordProps as ThisTypedComponentOptions } from "vue/types/options";
import { InnerScopedSlots, TsxComponentTypeInfo, EventHandler, EventHandlers, DeclareOnEvents, DeclareOn, DeclareProps } from "../types/base";
import { EventsNativeOn, AllHTMLAttributes, Events } from "../types/dom";
export declare type _TsxComponentInstanceV3<V extends Vue, Attributes, Props, PrefixedEvents, On, ScopedSlotArgs> = {
    _tsx: TsxComponentTypeInfo<Attributes, Props, PrefixedEvents, On>;
    $scopedSlots: InnerScopedSlots<ScopedSlotArgs>;
} & V;
export declare type _TsxComponentV3<V extends Vue, Attributes, Props, PrefixedEvents, On, ScopedSlotArgs> = VueConstructor<_TsxComponentInstanceV3<V, Attributes, Props, PrefixedEvents, On, ScopedSlotArgs>>;
export declare class Component<Props, PrefixedEvents = {}, ScopedSlotArgs = {}> extends Vue {
    _tsx: TsxComponentTypeInfo<{}, Props, PrefixedEvents, {}>;
    $scopedSlots: InnerScopedSlots<ScopedSlotArgs>;
}
/**
 * Create component from component options (Compatible with Vue.extend)
 */
export declare function createComponent<TProps, TPrefixedEvents = {}, TScopedSlots = {}>(opts: ComponentOptions<Vue> | FunctionalComponentOptions): _TsxComponentV3<Vue, {}, TProps, TPrefixedEvents, {}, TScopedSlots>;
export interface Factory<Props, PrefixedEvents, On, ScopedSlots> {
    convert<V extends Vue>(componentType: new (...args: any[]) => V): _TsxComponentV3<V, {}, Props, PrefixedEvents, On, ScopedSlots>;
    extendFrom<VC extends typeof Vue>(componentType: VC): _TsxComponentV3<InstanceType<VC>, {}, Props, PrefixedEvents, On, ScopedSlots> & Pick<VC, keyof VC>;
}
/**
 * Specify Props and Event types of component
 *
 * Usage:
 *  // Get TSX-supported component with props(`name`, `value`) and event(`onInput`)
 *  const NewComponent = tsx.ofType<{ name: string, value: string }, { onInput: string }>.convert(Component);
 */
export declare function ofType<Props, PrefixedEvents = {}, ScopedSlots = {}, On = {}>(): Factory<Props, PrefixedEvents, On, ScopedSlots>;
export declare function withNativeOn<VC extends typeof Vue>(componentType: VC): _TsxComponentV3<InstanceType<VC>, EventHandlers<EventsNativeOn> & {
    nativeOn?: EventHandlers<Events> & VNodeData["nativeOn"];
}, {}, {}, {}, {}>;
export declare function withHtmlAttrs<VC extends typeof Vue>(componentType: VC): _TsxComponentV3<InstanceType<VC>, AllHTMLAttributes, {}, {}, {}, {}>;
export declare function withUnknownProps<VC extends typeof Vue>(componentType: VC): _TsxComponentV3<InstanceType<VC>, Record<string, any>, {}, {}, {}, {}>;
export declare function withPropsObject<VC extends typeof Vue>(componentType: VC): _TsxComponentV3<InstanceType<VC> & {
    _tsx_allowPropsObject: true;
}, {}, {}, {}, {}, {}>;
/**
 * Experimental support for new typings introduced from Vue 2.5
 * Depending on some private types of vue, which may be changed by upgrade :(
 */
export declare type RequiredPropNames<PropsDef extends RecordPropsDefinition<any>> = {
    [K in keyof PropsDef]: PropsDef[K] extends {
        required: true;
    } ? K : never;
}[Extract<keyof PropsDef, string>];
export declare type PropsForOutside<Props, RequiredPropNames extends keyof Props> = {
    [K in RequiredPropNames]: Props[K];
} & {
    [K in Exclude<keyof Props, RequiredPropNames>]?: Props[K];
};
export interface ComponentFactory<BaseProps, PrefixedEvents, Events, ScopedSlotArgs, Super extends Vue> {
    create<Props, PropsDef extends RecordPropsDefinition<Props>, RequiredProps extends keyof Props = RequiredPropNames<PropsDef> & keyof Props>(options: FunctionalComponentOptions<Props, PropsDef & RecordPropsDefinition<Props>>, requiredProps?: RequiredProps[]): _TsxComponentV3<Super & Props, {}, PropsForOutside<Props, RequiredProps> & BaseProps, PrefixedEvents, Events, ScopedSlotArgs>;
    create<Data, Methods, Computed, Props, PropsDef extends RecordPropsDefinition<Props>, RequiredProps extends keyof Props = RequiredPropNames<PropsDef> & keyof Props>(options: ThisTypedComponentOptions<Super & Vue & {
        _tsx?: DeclareProps<PropsForOutside<Props, RequiredProps> & BaseProps>;
    }, Data, Methods, Computed, Props> & {
        props?: PropsDef;
    }, requiredPropsNames?: RequiredProps[]): _TsxComponentV3<Super & Data & Methods & Computed & Props, {}, PropsForOutside<Props, RequiredProps> & BaseProps, PrefixedEvents, Events, ScopedSlotArgs>;
    mixin<Data, Methods, Computed, Props>(mixinObject: ThisTypedComponentOptions<Vue, Data, Methods, Computed, Props>): ComponentFactory<BaseProps & Props, PrefixedEvents, Events, ScopedSlotArgs, Super & Data & Methods & Computed & Props>;
    mixin<VC extends typeof Vue>(mixinObject: VC): ComponentFactory<BaseProps, PrefixedEvents, Events, ScopedSlotArgs, Super & InstanceType<VC> & {
        $scopedSlots: InnerScopedSlots<ScopedSlotArgs>;
    }>;
}
export interface ExtendableComponentFactory<BaseProps, EventsWithPrefix, EventsWithoutPrefix, ScopedSlotArgs, Super extends Vue> extends ComponentFactory<BaseProps, EventsWithPrefix, EventsWithoutPrefix, ScopedSlotArgs, Super> {
    extendFrom<VC extends typeof Vue>(componentType: VC): ComponentFactory<BaseProps, EventsWithPrefix, EventsWithoutPrefix, ScopedSlotArgs, InstanceType<VC> & {
        $scopedSlots: InnerScopedSlots<ScopedSlotArgs>;
    }>;
}
export declare const componentFactory: ExtendableComponentFactory<{}, {}, {}, {}, Vue>;
export declare function componentFactoryOf<PrefixedEvents = {}, ScopedSlotArgs = {}, On = {}>(): ComponentFactory<{}, PrefixedEvents, On, ScopedSlotArgs, Vue & {
    _tsx: TsxComponentTypeInfo<{}, {}, PrefixedEvents, On>;
    $scopedSlots: InnerScopedSlots<ScopedSlotArgs>;
}>;
/**
 * Shorthand of `componentFactory.create`
 */
export declare const component: {
    <Props, PropsDef extends RecordPropsDefinition<Props>, RequiredProps extends keyof Props = { [K in keyof PropsDef]: PropsDef[K] extends {
        required: true;
    } ? K : never; }[Extract<keyof PropsDef, string>] & keyof Props>(options: FunctionalComponentOptions<Props, PropsDef & RecordPropsDefinition<Props>>, requiredProps?: RequiredProps[] | undefined): _TsxComponentV3<Vue & Props, {}, { [K_1 in RequiredProps]: Props[K_1]; } & { [K_2 in Exclude<keyof Props, RequiredProps>]?: Props[K_2] | undefined; }, {}, {}, {}>;
    <Data, Methods, Computed, Props_2, PropsDef_1 extends RecordPropsDefinition<Props_2>, RequiredProps_2 extends keyof Props_2 = { [K_3 in keyof PropsDef_1]: PropsDef_1[K_3] extends {
        required: true;
    } ? K_3 : never; }[Extract<keyof PropsDef_1, string>] & keyof Props_2>(options: object & ComponentOptions<Vue & {
        _tsx?: DeclareProps<{ [K_4 in RequiredProps_2]: Props_2[K_4]; } & { [K_5 in Exclude<keyof Props_2, RequiredProps_2>]?: Props_2[K_5] | undefined; }> | undefined;
    }, import("vue/types/options").DataDef<Data, Props_2, Vue & {
        _tsx?: DeclareProps<{ [K_4 in RequiredProps_2]: Props_2[K_4]; } & { [K_5 in Exclude<keyof Props_2, RequiredProps_2>]?: Props_2[K_5] | undefined; }> | undefined;
    }>, Methods, Computed, RecordPropsDefinition<Props_2>, Props_2> & ThisType<import("vue/types/vue").CombinedVueInstance<Vue & {
        _tsx?: DeclareProps<{ [K_4 in RequiredProps_2]: Props_2[K_4]; } & { [K_5 in Exclude<keyof Props_2, RequiredProps_2>]?: Props_2[K_5] | undefined; }> | undefined;
    }, Data, Methods, Computed, Readonly<Props_2>>> & {
        props?: PropsDef_1 | undefined;
    }, requiredPropsNames?: RequiredProps_2[] | undefined): _TsxComponentV3<Vue & Data & Methods & Computed & Props_2, {}, { [K_4 in RequiredProps_2]: Props_2[K_4]; } & { [K_5 in Exclude<keyof Props_2, RequiredProps_2>]?: Props_2[K_5] | undefined; }, {}, {}, {}>;
};
export declare const extendFrom: <VC extends VueConstructor<Vue>>(componentType: VC) => ComponentFactory<{}, {}, {}, {}, InstanceType<VC> & {
    $scopedSlots: InnerScopedSlots<{}>;
}>;
export declare function emit<Events, Name extends string & keyof Events>(vm: Vue & {
    _tsx: DeclareOn<Events>;
}, name: Name, ...args: Parameters<EventHandler<Events[Name]>>): void;
export declare function emitOn<Events, Name extends string & keyof Events>(vm: Vue & {
    _tsx: DeclareOnEvents<Events>;
}, name: Name, ...args: Parameters<EventHandler<Events[Name]>>): void;
export declare function emitUpdate<Props, Name extends string & keyof Props>(vm: Vue & {
    _tsx?: DeclareProps<Props>;
}, name: Name, value: Props[Name]): void;
